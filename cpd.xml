<?xml version="1.0" encoding="UTF-8"?>
<pmd-cpd>
<duplication lines="24" tokens="194">
<file line="127" path="/home/jan/DB/mapdb/src/main/java/org/mapdb/Fun.java"/>
<file line="200" path="/home/jan/DB/mapdb/src/main/java/org/mapdb/Fun.java"/>
<codefragment>
<![CDATA[
            final Tuple3 oo = (Tuple3) o;
            if(a!=oo.a){
                if(a==null || oo.a==HI) return -1;
                if(a==HI ||  oo.a==null) return 1;

                final int c = ((Comparable)a).compareTo(oo.a);
                if(c!=0) return c;
            }

            if(b!=oo.b){
                if(b==null || oo.b==HI) return -1;
                if(b==HI || oo.b==null) return 1;

                final int i = ((Comparable)b).compareTo(oo.b);
                if(i!=0) return i;
            }

            if(c!=oo.c){
                if(c==null || oo.c==HI) return -1;
                if(c==HI || oo.c==null) return 1;

                final int i = ((Comparable)c).compareTo(oo.c);
                if(i!=0) return i;
            }
]]>
</codefragment>
</duplication>
<duplication lines="41" tokens="173">
<file line="232" path="/home/jan/DB/mapdb/src/main/java/org/mapdb/StoreWAL.java"/>
<file line="292" path="/home/jan/DB/mapdb/src/main/java/org/mapdb/StoreWAL.java"/>
<codefragment>
<![CDATA[
            final long[] physPos;
            final long[] logPos;

            long indexVal = 0;
            long[] linkedRecords = getLinkedRecordsFromLog(ioRecid);
            if(linkedRecords==null){
                indexVal = index.getLong(ioRecid);
                linkedRecords = getLinkedRecordsIndexVals(indexVal);
            }

            structuralLock.lock();
            try{
                openLogIfNeeded();

                //free first record pointed from indexVal
                if(indexVal!=0)
                    freePhysPut(indexVal);

                //if there are more linked records, free those as well
                if(linkedRecords!=null){
                    for(int i=0; i<linkedRecords.length &&linkedRecords[i]!=0;i++){
                        freePhysPut(linkedRecords[i]);
                    }
                }


                //first get space in phys
                physPos = physAllocate(out.pos,false);
                //now get space in log
                logPos = logAllocate(physPos);

            }finally{
                structuralLock.unlock();
            }

            //write data into log
            walIndexVal((logPos[0]&MASK_OFFSET) - 1-8-8-1-8, ioRecid, physPos[0]);
            walPhysArray(out, physPos, logPos);

            modified.put(ioRecid,logPos);
        }finally{
]]>
</codefragment>
</duplication>
<duplication lines="29" tokens="161">
<file line="2231" path="/home/jan/DB/mapdb/src/main/java/org/mapdb/BTreeMap.java"/>
<file line="1193" path="/home/jan/DB/mapdb/src/main/java/org/mapdb/HTreeMap.java"/>
<codefragment>
<![CDATA[
        return new BTreeMap<K, V>(snapshot,treeRecid, defaultSerializer);
    }



    protected final Object modListenersLock = new Object();
    protected Bind.MapListener<K,V>[] modListeners = new Bind.MapListener[0];

    @Override
    public void addModificationListener(Bind.MapListener<K,V> listener) {
        synchronized (modListenersLock){
            Bind.MapListener<K,V>[] modListeners2 =
                    Arrays.copyOf(modListeners,modListeners.length+1);
            modListeners2[modListeners2.length-1] = listener;
            modListeners = modListeners2;
        }

    }

    @Override
    public void removeModificationListener(Bind.MapListener<K,V> listener) {
        synchronized (modListenersLock){
            for(int i=0;i<modListeners.length;i++){
                if(modListeners[i]==listener) modListeners[i]=null;
            }
        }
    }

    protected void notify(K key, V oldValue, V newValue) {
]]>
</codefragment>
</duplication>
<duplication lines="23" tokens="156">
<file line="1366" path="/home/jan/DB/mapdb/src/main/java/org/mapdb/BTreeMap.java"/>
<file line="1399" path="/home/jan/DB/mapdb/src/main/java/org/mapdb/BTreeMap.java"/>
<codefragment>
<![CDATA[
    protected Entry<K, V> findLarger(K key, boolean inclusive) {
        if(key==null) return null;
        K v = (K) key;
        final long rootRecid = engine.get(rootRecidRef, Serializer.LONG_SERIALIZER);
        long current = rootRecid;
        BNode A = engine.get(current, nodeSerializer);

        //dive until  leaf
        while(!A.isLeaf()){
            current = nextDir((DirNode) A, v);
            A = engine.get(current, nodeSerializer);
        }

        //now at leaf level
        LeafNode leaf = (LeafNode) A;
        //follow link until first matching node is found
        final int comp = inclusive?1:0;
        while(true){
            for(int i=1;i<leaf.keys.length-1;i++){
                if(leaf.keys[i]==null) continue;

                if(comparator.compare(key, leaf.keys[i])<comp){
                    return makeEntry(leaf.keys[i], hasValues?valExpand(leaf.vals[i]):Utils.EMPTY_STRING);
]]>
</codefragment>
</duplication>
<duplication lines="16" tokens="130">
<file line="70" path="/home/jan/DB/mapdb/src/main/java/org/mapdb/Fun.java"/>
<file line="127" path="/home/jan/DB/mapdb/src/main/java/org/mapdb/Fun.java"/>
<file line="200" path="/home/jan/DB/mapdb/src/main/java/org/mapdb/Fun.java"/>
<codefragment>
<![CDATA[
            final Tuple2 oo = (Tuple2) o;
            if(a!=oo.a){
                if(a==null || oo.a==HI) return -1;
                if(a==HI || oo.a==null) return 1;

                final int c = ((Comparable)a).compareTo(oo.a);
                if(c!=0) return c;
            }

            if(b!=oo.b){
                if(b==null || oo.b==HI) return -1;
                if(b==HI || oo.b==null) return 1;

                final int i = ((Comparable)b).compareTo(oo.b);
                if(i!=0) return i;
            }
]]>
</codefragment>
</duplication>
<duplication lines="21" tokens="127">
<file line="1631" path="/home/jan/DB/mapdb/src/main/java/org/mapdb/BTreeMap.java"/>
<file line="1776" path="/home/jan/DB/mapdb/src/main/java/org/mapdb/BTreeMap.java"/>
<codefragment>
<![CDATA[
                return ((BTreeMap.SubMap<E,Object>)m).keyIterator();
        }
        @Override
		public boolean equals(Object o) {
            if (o == this)
                return true;
            if (!(o instanceof Set))
                return false;
            Collection<?> c = (Collection<?>) o;
            try {
                return containsAll(c) && c.containsAll(this);
            } catch (ClassCastException unused)   {
                return false;
            } catch (NullPointerException unused) {
                return false;
            }
        }
        @Override
		public Object[] toArray()     { return toList(this).toArray();  }
        @Override
		public <T> T[] toArray(T[] a) { return toList(this).toArray(a); }
]]>
</codefragment>
</duplication>
<duplication lines="31" tokens="126">
<file line="275" path="/home/jan/DB/mapdb/src/main/java/org/mapdb/StoreDirect.java"/>
<file line="271" path="/home/jan/DB/mapdb/src/main/java/org/mapdb/StoreWAL.java"/>
<codefragment>
<![CDATA[
            put2(out, ioRecid, indexVals);
        }finally{
            lock.unlock();
        }
        recycledDataOuts.offer(out);
    }

    @Override
    public <A> boolean compareAndSwap(long recid, A expectedOldValue, A newValue, Serializer<A> serializer) {
        final long ioRecid = IO_USER_START + recid*8;
        final Lock lock  = locks[Utils.longHash(recid)&Utils.LOCK_MASK].writeLock();
        lock.lock();

        DataOutput2 out;
        try{
            /*
             * deserialize old value
             */

            A oldVal = get2(ioRecid,serializer);

            /*
             * compare oldValue and expected
             */
            if((oldVal == null && expectedOldValue!=null) || (oldVal!=null && !oldVal.equals(expectedOldValue)))
                return false;

            /*
             * write new value
             */
             out = serialize(newValue, serializer);
]]>
</codefragment>
</duplication>
<duplication lines="14" tokens="122">
<file line="653" path="/home/jan/DB/mapdb/src/main/java/org/mapdb/LongConcurrentLRUMap.java"/>
<file line="681" path="/home/jan/DB/mapdb/src/main/java/org/mapdb/LongConcurrentLRUMap.java"/>
<codefragment>
<![CDATA[
  public Map<Long,V> getOldestAccessedItems(int n) {
    Map<Long,V> result = new LinkedHashMap<Long,V>();
    if (n <= 0)
      return result;
    TreeSet<CacheEntry<V>> tree = new TreeSet<CacheEntry<V>>();
    markAndSweepLock.lock();
    try {
        for( Iterator<CacheEntry<V>> iter = map.valuesIterator(); iter.hasNext();){
        CacheEntry<V> ce = iter.next();
        ce.lastAccessedCopy = ce.lastAccessed;
        if (tree.size() < n) {
          tree.add(ce);
        } else {
          if (ce.lastAccessedCopy < tree.first().lastAccessedCopy) {
]]>
</codefragment>
</duplication>
<duplication lines="3" tokens="121">
<file line="72" path="/home/jan/DB/mapdb/src/main/java/org/mapdb/EncryptionXTEA.java"/>
<file line="95" path="/home/jan/DB/mapdb/src/main/java/org/mapdb/EncryptionXTEA.java"/>
<codefragment>
<![CDATA[
    private void encryptBlock(byte[] in, byte[] out, int off) {
        int y = (in[off] << 24) | ((in[off+1] & 255) << 16) | ((in[off+2] & 255) << 8) | (in[off+3] & 255);
        int z = (in[off+4] << 24) | ((in[off+5] & 255) << 16) | ((in[off+6] & 255) << 8) | (in[off+7] & 255);
]]>
</codefragment>
</duplication>
<duplication lines="5" tokens="118">
<file line="91" path="/home/jan/DB/mapdb/src/main/java/org/mapdb/EncryptionXTEA.java"/>
<file line="114" path="/home/jan/DB/mapdb/src/main/java/org/mapdb/EncryptionXTEA.java"/>
<codefragment>
<![CDATA[
        out[off] = (byte) (y >> 24); out[off+1] = (byte) (y >> 16); out[off+2] = (byte) (y >> 8); out[off+3] = (byte) y;
        out[off+4] = (byte) (z >> 24); out[off+5] = (byte) (z >> 16); out[off+6] = (byte) (z >> 8); out[off+7] = (byte) z;
    }

    private void decryptBlock(byte[] in, byte[] out, int off) {
]]>
</codefragment>
</duplication>
<duplication lines="22" tokens="113">
<file line="1238" path="/home/jan/DB/mapdb/src/main/java/org/mapdb/BTreeMap.java"/>
<file line="2030" path="/home/jan/DB/mapdb/src/main/java/org/mapdb/BTreeMap.java"/>
<codefragment>
<![CDATA[
    }


    @Override
    public Entry<K, V> pollFirstEntry() {
        while(true){
            Entry<K, V> e = firstEntry();
            if(e==null || remove(e.getKey(),e.getValue())){
                return e;
            }
        }
    }

    @Override
    public Entry<K, V> pollLastEntry() {
        while(true){
            Entry<K, V> e = lastEntry();
            if(e==null || remove(e.getKey(),e.getValue())){
                return e;
            }
        }
    }
]]>
</codefragment>
</duplication>
<duplication lines="24" tokens="105">
<file line="253" path="/home/jan/DB/mapdb/src/main/java/org/mapdb/StoreDirect.java"/>
<file line="307" path="/home/jan/DB/mapdb/src/main/java/org/mapdb/StoreDirect.java"/>
<codefragment>
<![CDATA[
            long indexVal = index.getLong(ioRecid);
            long[] indexVals = spaceReclaimTrack ? getLinkedRecordsIndexVals(indexVal) : null;
            structuralLock.lock();
            try{

                if(spaceReclaimTrack){
                    //free first record pointed from indexVal
                    freePhysPut(indexVal);

                    //if there are more linked records, free those as well
                    if(indexVals!=null){
                        for(int i=0;i<indexVals.length && indexVals[i]!=0;i++){
                            freePhysPut(indexVals[i]);
                        }
                    }
                }

                indexVals = physAllocate(out.pos,true);
            }finally {
                structuralLock.unlock();
            }

            put2(out, ioRecid, indexVals);
        }finally{
]]>
</codefragment>
</duplication>
<duplication lines="7" tokens="100">
<file line="455" path="/home/jan/DB/mapdb/src/main/java/org/mapdb/BTreeKeySerializer.java"/>
<file line="626" path="/home/jan/DB/mapdb/src/main/java/org/mapdb/BTreeKeySerializer.java"/>
<codefragment>
<![CDATA[
            Tuple3KeySerializer that = (Tuple3KeySerializer) o;

            if (aComparator != null ? !aComparator.equals(that.aComparator) : that.aComparator != null) return false;
            if (aSerializer != null ? !aSerializer.equals(that.aSerializer) : that.aSerializer != null) return false;
            if (bComparator != null ? !bComparator.equals(that.bComparator) : that.bComparator != null) return false;
            if (bSerializer != null ? !bSerializer.equals(that.bSerializer) : that.bSerializer != null) return false;
            if (cSerializer != null ? !cSerializer.equals(that.cSerializer) : that.cSerializer != null) return false;
]]>
</codefragment>
</duplication>
</pmd-cpd>